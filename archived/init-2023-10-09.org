#+TITLE: Emacs configuration file
#+AUTHOR: Globz
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes
#+LAST_MODIFIED: 2023-10-07

* About

  This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. 

  This configuration file is heavily based on the original work of 
  =Lars Tveito=. 

  The original configuration is located @ https://github.com/larstvei/dot-emacs


  This is my attempt to keep my =~/.emacs.d= tidy and easy to manage while also
  giving me the maximum amount of powerful tools and functionalities without
  slowing down this glorious Lisp Machine to a grinding halt. 


  Follow these simple steps in order to enable this configuration on your
  system :

  Clone the repo.
  #+BEGIN_SRC sh :tangle no
  git clone https://github.com/globz/emacs-conf
  #+END_SRC

  Backup your old =~/.emacs.d= (if necessary).
  #+BEGIN_SRC sh :tangle no
  mv ~/.emacs.d ~/.emacs.d-bak
  #+END_SRC

  Backup your old =~/.emacs=-file (if necessary).
  #+BEGIN_SRC sh :tangle no
  mv ~/.emacs ~/.emacs-bak
  #+END_SRC

  And finally
  #+BEGIN_SRC sh :tangle no
  mv emacs-conf ~/.emacs.d
  #+END_SRC

  On first run it should install a bunch of packages (this might take a
  while), and you might have to restart your Emacs the first time.

* Configurations
** Meta

   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Any changes in the =init.el= will be overwritten by saving
   =init.org=. The =init.el= in this repo should not be tracked by git, and
   is replaced the first time Emacs is started (assuming it has been renamed
   to =~/.emacs.d=).

   Emacs can't load =.org=-files directly, but =org-mode= provides functions
   to extract the code blocks and write them to a file. There are multiple
   ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
   could just use =org-babel-load-file=, but I had problems with
   byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
   but the git commits got a little messy. So here is a new approach.

   When this configuration is loaded for the first time, the ~init.el~ is
   the file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
   ;; This file replaces itself with the actual configuration at first run.

   ;; We can't tangle without org!
   (require 'org)
   ;; Open the configuration
   (find-file (concat user-emacs-directory "init.org"))
   ;; tangle it
   (org-babel-tangle)
   ;; load it
   (load-file (concat user-emacs-directory "init.el"))
   ;; finally byte-compile it
   (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   It tangles the org-file, so that this file is overwritten with the actual
   configuration.

   There is no reason to track the =init.el= that is generated; by running
   the following command =git= will not bother tracking it:

   #+BEGIN_SRC sh :tangle no
   git update-index --assume-unchanged init.el
   #+END_SRC

   If one wishes to make changes to the repo-version of =init.el= start
   tracking again with:

   #+BEGIN_SRC sh :tangle no
   git update-index --no-assume-unchanged init.el
   #+END_SRC

   I want lexical scoping for the init-file, which can be specified in the
   header. The first line of the configuration is as follows:

   #+BEGIN_SRC emacs-lisp
   ;;; -*- lexical-binding: t -*-
   #+END_SRC

   The =init.el= should (after the first run) mirror the source blocks in
   the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
   extracts the code blocks from the current file into a source-specific
   file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

** Packages

   Managing extensions for Emacs is simplified using =package= which is
   built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl-lib= is a library that contains many functions from
   Common Lisp, and comes in handy quite often, so we want to make sure it's
   loaded, along with =package=, which is obviously needed.

   #+BEGIN_SRC emacs-lisp
   (require 'cl-lib)
   (require 'package)
   (package-initialize)
   #+END_SRC

   Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
   archive and is well maintained.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
   (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
   ; Pinned packages
   ; elixir-mode stable is not working properly with Elixir 1.7
   ;(add-to-list 'package-pinned-packages '(elixir-mode . "melpa-stable") t)
   #+END_SRC

   The configuration assumes that the packages listed below are
   installed. To ensure we install missing packages if they are missing.

   #+BEGIN_SRC emacs-lisp
      (let* ((package--builtins nil)
             (packages
              '(auto-compile           ; automatically compile Emacs Lisp libraries
                ;cider                 ; Clojure Interactive Development Environment
                ;clj-refactor          ; A collection of clojure refactoring functions
                company                ; Modular in-buffer completion framework for Emacs
                company-ctags          ; Fastest auto-completion using Company and Ctags
                counsel-etags          ; Fast, energy-saving, and powerful code navigation solution.
                define-word            ; display the definition of word at point
                diminish               ; Diminished modes from modeline
                drag-stuff             ; Drag stuff around in Emacs
                erlang                 ; Erlang major mode
                elixir-mode            ; Elixir major mode
                eglot                  ; The Emacs Client for LSP servers
                expand-region          ; Increase selected region by semantic units
                ess                    ; Emacs Speaks Statistics (ESS)
                focus                  ; Dim color of text in surrounding sections
                idle-require           ; load elisp libraries while Emacs is idle
                geiser                 ; GNU Emacs and Scheme talk to each other
                git-gutter-fringe      ; Fringe version of git-gutter.el
                golden-ratio           ; Automatic resizing windows to golden ratio
                haskell-mode           ; A Haskell editing mode
                ;helm                  ; Incremental and narrowing framework
                ;helm-ag               ; the silver searcher with helm interface
                ;helm-company          ; Helm interface for company-mode
                ;helm-dash             ; Offline documentation using Dash docsets.
                ;helm-projectile       ; Helm integration for Projectile
                ;helm-swoop            ; Efficiently hopping squeezed lines
                jedi                   ; Python auto-completion for Emacs
                js2-mode               ; Improved JavaScript editing mode
                json-mode              ; Major mode for editing JSON files
                ;lsp-mode              ; Language Server Protocol Support for Emacs   
                magit                  ; control Git from Emacs
                markdown-mode          ; Emacs Major mode for Markdown-formatted files
                material-theme         ; A Theme based on Google Material Design
                matlab-mode            ; MATLAB integration with Emacs
                monokai-theme          ; Dark theme
                multiple-cursors       ; Multiple cursors for Emacs
                olivetti               ; Minor mode for a nice writing environment
                org                    ; Outline-based notes management and organizer
                org-ref                ; citations bibliographies in org-mode
                paredit                ; minor mode for editing parentheses
                pdf-tools              ; Emacs support library for PDF files
                php-mode               ; PHP Mode is a major mode for editing PHP script
                projectile             ; Manage and navigate projects in Emacs easily
                slime                  ; Superior Lisp Interaction Mode for Emacs
                try                    ; Try out Emacs packages
                use-package            ; A use-package declaration for simplifying your .emacs
                which-key              ; Display available keybindings in popup
                yasnippet              ; YASnippet is a template system for Emacs .
                yasnippet-snippets     ; YASnippet official snippet collections
                elixir-yasnippets)))   ; Elixir YASnippet
        (ignore-errors ;; This package is only relevant for Mac OS X.
          (when (memq window-system '(mac ns))
            (push 'exec-path-from-shell packages)
            (push 'reveal-in-osx-finder packages))
          (let ((packages (cl-remove-if 'package-installed-p packages)))
            (when packages
              ;; Install uninstalled packages
              (package-refresh-contents)
              (mapc 'package-install packages)))))
   ;; Needed to handle our use-package configuration
   (eval-when-compile
     (require 'use-package))
   #+END_SRC
** Require

   Some features are not loaded by default to minimize initialization time,
   so they have to be required (or loaded, if you will). =require=-calls
   tends to lead to the largest bottleneck's in a configuration. 
   =idle-require= delays the =require=-calls to a time where
   Emacs is in idle. So this is great for stuff you eventually want to load,
   but is not a high priority.

   #+BEGIN_SRC emacs-lisp
   (require 'idle-require)             ; Need in order to use idle-require

   (dolist (feature
            '(auto-compile             ; auto-compile .el files
              jedi                     ; auto-completion for python
              matlab                   ; matlab-mode
              ob-matlab                ; org-babel matlab
              ox-latex                 ; the latex-exporter (from org)
              ox-md                    ; Markdown exporter (from org)
              recentf                  ; recently opened files
              tex-mode))               ; TeX, LaTeX, and SliTeX mode commands   
     (idle-require feature))

   (setq idle-require-idle-delay 5)
   (idle-require-mode 1)
   #+END_SRC

** Sane defaults

   These are what /I/ consider to be saner defaults.

   We can set variables to whatever value we'd like using =setq=.

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         custom-file (make-temp-file "")   ; Discard customization's
         default-input-method "TeX"        ; Use TeX when toggling input method
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-message t         ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet 
         sentence-end-double-space nil)    ; No double space
   #+END_SRC

   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.

   #+BEGIN_SRC emacs-lisp
   (setq-default fill-column 79                    ; Maximum line width
                 truncate-lines t                  ; Don't fold lines
                 indent-tabs-mode nil              ; Use spaces instead of tabs
                 split-width-threshold 160         ; Split verticly by default
                 split-height-threshold nil        ; Split verticly by default
                 auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
   #+END_SRC

   The =load-path= specifies where Emacs should look for =.el=-files (or
   Emacs lisp files). I have a directory called =site-lisp= where I keep all
   extensions that have been installed manually (these are mostly my own
   projects).

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (setq version-control t  ;; Use version numbers for backups.
      kept-new-versions 10  ;; Number of newest versions to keep.
      kept-old-versions 0   ;; Number of oldest versions to keep.
      delete-old-versions t ;; Don't ask to delete excess backup versions.
      backup-by-copying t)  ;; Copy all files, don't rename them.
   (setq vc-make-backup-files t)
   ;; Default and per-save backups go here:
   (setq backup-directory-alist '(("" . "~/.emacs.d/backup/per-save")))

   (defun force-backup-of-buffer ()
   ;; Make a special "per session" backup at the first save of each
   ;; emacs session.
   (when (not buffer-backed-up)
    ;; Override the default parameters for per-session backups.
    (let ((backup-directory-alist '(("" . "~/.emacs.d/backup/per-session")))
          (kept-new-versions 3))
      (backup-buffer)))
   ;; Make a "per save" backup on each save.  The first save results in
   ;; both a per-session and a per-save backup, to keep the numbering
   ;; of per-save backups consistent.
   (let ((buffer-backed-up nil))
    (backup-buffer)))
   (add-hook 'before-save-hook  'force-backup-of-buffer)
   #+END_SRC

   Set =utf-8= as preferred coding system.

   #+BEGIN_SRC emacs-lisp
   (prefer-coding-system 'utf-8)
   (set-default-coding-systems 'utf-8)
   (set-terminal-coding-system 'utf-8)
   (set-keyboard-coding-system 'utf-8)
   (set-language-environment "UTF-8")
   (setq-default buffer-file-coding-system 'utf-8-unix)
   (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
   #+END_SRC

   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   Automatically revert =doc-view=-buffers when the file changes on disk.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC
** Modes

   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              blink-cursor-mode))          ; The blinking cursor gets old
     (funcall mode 0))
   #+END_SRC

   Let's apply the same technique for enabling modes that are disabled by
   default.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              column-number-mode           ; Show column number in mode line
              delete-selection-mode        ; Replace selected text
              dirtrack-mode                ; directory tracking in *shell*
              drag-stuff-global-mode       ; Drag stuff around
              global-company-mode          ; Auto-completion everywhere
              global-git-gutter-mode       ; Show changes latest commit
              global-prettify-symbols-mode ; Greek letters should look greek
              projectile-global-mode       ; Manage and navigate projects
              recentf-mode                 ; Recently opened files
              show-paren-mode              ; Highlight matching parentheses
              which-key-mode))             ; Available keybindings in popup
     (funcall mode 1))
   #+END_SRC

** Visual

   Change the color-theme to =leuven=.

   #+BEGIN_SRC emacs-lisp
   (load-theme 'leuven t)
   #+END_SRC

   =leuven= is my preferred light theme, but =monokai= makes a very nice
   dark theme. I want to be able to cycle between these.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (let ((themes '#1=(leuven monokai material . #1#)))
       (lambda ()
         (interactive)
         ;; Rotates the theme cycle and changes the current theme.
         (load-theme (car (setq themes (cdr themes))) t))))
   #+END_SRC

   Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

   #+BEGIN_SRC emacs-lisp
   (cond ((member "Hasklig" (font-family-list))
          (set-face-attribute 'default nil :font "Hasklig-14"))
         ((member "Inconsolata" (font-family-list))
          (set-face-attribute 'default nil :font "Inconsolata-14")))
   #+END_SRC

   [[http://www.eskimo.com/~seldon/diminish.el][diminish.el]] allows you to hide or abbreviate their presence in the
   modeline. I rarely look at the modeline to find out what minor-modes are
   enabled, so I disable every global minor-mode, and some for lisp editing.

   To ensure that the mode is loaded before diminish it, we should use
   ~with-eval-after-load~. To avoid typing this multiple times a small macro
   is provided.

   #+BEGIN_SRC emacs-lisp
   (defmacro safe-diminish (file mode &optional new-name)
     `(with-eval-after-load ,file
        (diminish ,mode ,new-name)))

   (diminish 'auto-fill-function)
   (safe-diminish "eldoc" 'eldoc-mode)
   (safe-diminish "flyspell" 'flyspell-mode)
   ;;(safe-diminish "helm-mode" 'helm-mode)
   (safe-diminish "projectile" 'projectile-mode)
   (safe-diminish "paredit" 'paredit-mode "()")
   #+END_SRC

   New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   #+END_SRC
   
** PDF Tools

   [[https://github.com/politza/pdf-tools][PDF Tools]] makes a huge improvement on the built-in [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]]; the only
   drawback is the =pdf-tools-install= (which has to be executed before the
   package can be used) takes a couple of /seconds/ to execute. Instead of
   running it at init-time, we'll run it whenever a PDF is opened. Note that
   it's only slow on the first run!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode)
   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
   #+END_SRC

** Flyspell

   Flyspell does not work on Windows 10 x64 without making use of ispell with
   Hunspell... install Hunspell to the exec-path below on your Windows machine
   more details can be found here related to the installation setup : 
   https://lists.gnu.org/archive/html/help-gnu-emacs/2014-04/msg00030.html
   *I believe this is no longer needed with latest WSL, simply install ispell + missing dictionary on your WSL instance*

   #+BEGIN_SRC emacs-lisp
   ;; check OS type for Windows Only 
   ;; (cond
   ;;  ((string-equal system-type "windows-nt") ; Microsoft Windows
   ;;    (add-to-list 'exec-path "C:/Hunspell/bin/")
   ;;      (setq ispell-program-name (locate-file "hunspell"
   ;;            exec-path exec-suffixes 'file-executable-p))))
   #+END_SRC
   
   Flyspell offers on-the-fly spell checking. We can enable flyspell for all
   text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

   #+BEGIN_SRC emacs-lisp
   (defun cycle-languages ()
     "Changes the ispell dictionary to the first element in
   ISPELL-LANGUAGES, and returns an interactive function that cycles
   the languages in ISPELL-LANGUAGES when invoked."
     (let ((ispell-languages '#1=("american" "francais" . #1#)))
       (ispell-change-dictionary (car ispell-languages))
       (lambda ()
         (interactive)
         ;; Rotates the languages cycle and changes the ispell dictionary.
         (ispell-change-dictionary
          (car (setq ispell-languages (cdr ispell-languages)))))))
   #+END_SRC
   
   =flyspell= signals an error if there is no spell-checking tool is
   installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
   only try to enable =flyspell= if a spell-checking tool is available. Also
   we want to enable cycling the languages by typing =C-c l=, so we bind the
   function returned from =cycle-languages=.

   #+BEGIN_SRC emacs-lisp
   (defadvice turn-on-flyspell (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
   (defadvice flyspell-prog-mode (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

** Org

   When editing org-files with source-blocks, we want the source blocks to
   be themed as they would in their native mode.

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC

   This is quite an ugly fix for allowing code markup for expressions like
   ="this string"=, because the quotation marks causes problems.

   #+BEGIN_SRC emacs-lisp
   ;;(require 'org)
   (eval-after-load "org"
     '(progn
        (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
        (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
   #+END_SRC

   Set initial visibility to =overview= (folded state)

   #+BEGIN_SRC emacs-lisp
   (setq org-startup-folded t)
   #+END_SRC

** Interactive functions
   <<sec:defuns>>

   =just-one-space= removes all whitespace around a point - giving it a
   negative argument it removes newlines as well. We wrap a interactive
   function around it to be able to bind it to a key. In Emacs 24.4
   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   when run in succession it cycles between one, zero and the original
   number of spaces.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-spacing-delete-newlines ()
     "Removes whitespace before and after the point."
     (interactive)
     (if (version< emacs-version "24.4")
         (just-one-space -1)
       (cycle-spacing -1)))
   #+END_SRC

   Often I want to find other occurrences of a word I'm at, or more
   specifically the symbol (or tag) I'm at. The
   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   I don't want to be bothered with the =isearch= interface. Rather jump
   quickly between occurrences of a symbol, or if non is found, don't do
   anything.

   #+BEGIN_SRC emacs-lisp
   (defun jump-to-symbol-internal (&optional backwardp)
     "Jumps to the next symbol near the point if such a symbol
   exists. If BACKWARDP is non-nil it jumps backward."
     (let* ((point (point))
            (bounds (find-tag-default-bounds))
            (beg (car bounds)) (end (cdr bounds))
            (str (isearch-symbol-regexp (find-tag-default)))
            (search (if backwardp 'search-backward-regexp
                      'search-forward-regexp)))
       (goto-char (if backwardp beg end))
       (funcall search str nil t)
       (cond ((<= beg (point) end) (goto-char point))
             (backwardp (forward-char (- point beg)))
             (t  (backward-char (- end point))))))

   (defun jump-to-previous-like-this ()
     "Jumps to the previous occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal t))

   (defun jump-to-next-like-this ()
     "Jumps to the next occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal))
   #+END_SRC

   I sometimes regret killing the =*scratch*=-buffer, and have realized I
   never want to actually kill it. I just want to get it out of the way, and
   clean it up. The function below does just this for the
   =*scratch*=-buffer, and works like =kill-this-buffer= for any other
   buffer. It removes all buffer content and buries the buffer (this means
   making it the least likely candidate for =other-buffer=).

   #+BEGIN_SRC emacs-lisp
   (defun kill-this-buffer-unless-scratch ()
     "Works like `kill-this-buffer' unless the current buffer is the
   ,*scratch* buffer. In witch case the buffer content is deleted and
   the buffer is buried."
     (interactive)
     (if (not (string= (buffer-name) "*scratch*"))
         (kill-this-buffer)
       (delete-region (point-min) (point-max))
       (switch-to-buffer (other-buffer))
       (bury-buffer "*scratch*")))
   #+END_SRC

   To duplicate either selected text or a line we define this interactive
   function.

   #+BEGIN_SRC emacs-lisp
   (defun duplicate-thing (comment)
     "Duplicates the current line, or the region if active. If an argument is
   given, the duplicated region will be commented out."
     (interactive "P")
     (save-excursion
       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
             (end   (if (region-active-p) (region-end) (point-at-eol))))
         (goto-char end)
         (unless (region-active-p)
           (newline))
         (insert (buffer-substring start end))
         (when comment (comment-region start end)))))
   #+END_SRC

   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   Org mode does currently not support synctex (which enables you to jump from
   a point in your TeX-file to the corresponding point in the pdf), and it
   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

   Calling this function from an org-buffer jumps to the corresponding section
   in the exported pdf (given that the pdf-file exists), using pdf-tools.

   #+BEGIN_SRC emacs-lisp
   (defun org-sync-pdf ()
     (interactive)
     (let ((headline (nth 4 (org-heading-components)))
           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
       (when (file-exists-p pdf)
         (find-file-other-window pdf)
         (pdf-links-action-perform
          (cl-find headline (pdf-info-outline pdf)
                   :key (lambda (alist) (cdr (assoc 'title alist)))
                   :test 'string-equal)))))
   #+END_SRC
    
   Given a list of strings separated by newlines, in example :
 
   josh
   sam
   jed
   C.J.
   toby
  
   You select the text, and run =arrayify=. 

   You can optionally provide a quote character and receive this output:
   "josh", "jed", "sam", "C.J.", "toby"
  
   This is incredibly useful for taking lists of IDs, or email addresses, etc,
   and transforming them for pasting into documents, emails or "in" clauses in SQL, etc.
   It is unbelievably useful.

   #+BEGIN_SRC emacs-lisp
  (defun arrayify (start end quote)
    "Turn strings on newlines into a QUOTEd, comma-separated one-liner."
    (interactive "r\nMQuote: ")
    (let ((insertion
           (mapconcat
            (lambda (x) (format "%s%s%s" quote x quote))
            (split-string (buffer-substring start end)) ", ")))
      (delete-region start end)
      (insert insertion)))
   #+END_SRC

org-source-block template

   #+BEGIN_SRC emacs-lisp

   (defun org-insert-source-block (name language)
     "Asks name, language of org-source-block.
   Inserts org-mode source code snippet"
     (interactive "sInserting new org source block -> block name? 
sblock language?  ")
     (insert 
      (if (string= name "")
          ""
        (concat "#+NAME: " name) )
      (format "
   ,#+BEGIN_SRC %s

   ,#+END_SRC" language
   )
      )
     (forward-line -1)
     (goto-char (line-end-position))
     )

   #+END_SRC

** Advice

   An advice can be given to a function to make it behave differently. 

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   These functions provide something close to ~text-scale-mode~, but for every
   buffer, including the minibuffer and mode line.

   #+BEGIN_SRC emacs-lisp
   (let* ((default (face-attribute 'default :height))
                  (size default))

     (defun global-scale-default ()
       (interactive)
       (setq size default)
       (global-scale-internal size))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (incf size 20)))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (decf size 20)))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-transient-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-=") 'global-scale-up)
          (define-key map (kbd "C-+") 'global-scale-up)
          (define-key map (kbd "C--") 'global-scale-down)
          (define-key map (kbd "C-0") 'global-scale-default) map))))
   #+END_SRC

* Mode specific
** Company

   Enable company-ctags

   #+BEGIN_SRC emacs-lisp
(with-eval-after-load 'company
  (company-ctags-auto-setup))
   #+END_SRC

** Shell

   Inspired by [[https://github.com/torenord/.emacs.d][torenord]], I maintain quick access to shell buffers with bindings
   ~M-1~ to ~M-9~. In addition, the ~M-§~ (on an international English
   keyboard) is bound toggle between the last visited shell, and the last
   visited non-shell buffer. The following functions facilitate this, and are
   bound in the [[Key bindings]] section.

   #+BEGIN_SRC emacs-lisp
   (let ((last-shell ""))
     (defun toggle-shell ()
       (interactive)
       (cond ((string-match-p "^\\*shell<[1-9][0-9]*>\\*$" (buffer-name))
              (goto-non-shell-buffer))
             ((get-buffer last-shell) (switch-to-buffer last-shell))
             (t (shell (setq last-shell "*shell<1>*")))))

     (defun switch-shell (n)
       (let ((buffer-name (format "*shell<%d>*" n)))
         (setq last-shell buffer-name)
         (cond ((get-buffer buffer-name)
                (switch-to-buffer buffer-name))
               (t (shell buffer-name)
                  (rename-buffer buffer-name)))))

     (defun goto-non-shell-buffer ()
       (let* ((r "^\\*shell<[1-9][0-9]*>\\*$")
              (shell-buffer-p (lambda (b) (string-match-p r (buffer-name b))))
              (non-shells (cl-remove-if shell-buffer-p (buffer-list))))
         (when non-shells
           (switch-to-buffer (first non-shells))))))
   #+END_SRC

   Don't query whether or not the ~shell~-buffer should be killed, just kill
   it.

   #+BEGIN_SRC emacs-lisp
   (defadvice shell (after kill-with-no-query nil activate)
     (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil))
   #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   The =clear-shell= should only be bound in =comint-mode=, which is a mode
   most shell and REPL's is derived from.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC
** Lisp

   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(cider-repl-mode
                   clojure-mode
                   ielm-mode
                   geiser-repl-mode
                   slime-repl-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC

*** Clojure

    #+BEGIN_SRC emacs-lisp
    (add-hook 'cider-repl-mode-hook (lambda () (local-set-key (kbd "C-l") 'cider-repl-clear-buffer)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
    (setq cider-cljs-lein-repl
          "(do (require 'figwheel-sidecar.repl-api)
               (figwheel-sidecar.repl-api/start-figwheel!)
               (figwheel-sidecar.repl-api/cljs-repl))")
    #+END_SRC

*** Common lisp
    
    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
    provides code evaluation and other great features, a must have for a
    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
    and you can install Slime following the instructions from the site along
    with this snippet.

    #+BEGIN_SRC emacs-lisp
    (defun activate-slime-helper ()
      (when (file-exists-p "~/.quicklisp/slime-helper.el")
        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
        (define-key slime-repl-mode-map (kbd "C-l")
          'slime-repl-clear-buffer))
      (remove-hook 'lisp-mode-hook #'activate-slime-helper))

    (add-hook 'lisp-mode-hook #'activate-slime-helper)
    #+END_SRC

    We can specify what Common Lisp program Slime should use (I use SBCL).

    #+BEGIN_SRC emacs-lisp
    (setq inferior-lisp-program "sbcl")
    #+END_SRC

    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].

    #+BEGIN_SRC emacs-lisp
    (setq lisp-loop-forms-indentation   6
          lisp-simple-loop-indentation  2
          lisp-loop-keyword-indentation 6)
    #+END_SRC

*** Scheme

    [[http://www.nongnu.org/geiser/][Geiser]] provides features similar to Slime for Scheme editing. Everything
    works pretty much out of the box, we only need to add auto completion,
    and specify which scheme-interpreter we prefer.

    @invocation > run-geiser

    #+BEGIN_SRC emacs-lisp
    (eval-after-load "geiser"
      '(setq geiser-active-implementations '(chez)))
    #+END_SRC

*** Chicken

    Chicken provides a scheme which compiles to C and here
    we specify which scheme-interpreter we prefer.

    @invocation > run-scheme

    #+BEGIN_SRC emacs-lisp
    (setq scheme-program-name "csi -:c")
    #+END_SRC

** LaTeX and org-mode LaTeX export


   =.tex=-files should be associated with =latex-mode= instead of
   =tex-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
   #+END_SRC

   Use ~biblatex~ for bibliography.

   #+BEGIN_SRC emacs-lisp
   (setq-default bibtex-dialect 'biblatex)
   #+END_SRC

   I like using the [[https://code.google.com/p/minted/][Minted]] package for source blocks in LaTeX. To make org
   use this we add the following snippet.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'org
     '(add-to-list 'org-latex-packages-alist '("" "minted")))
   (setq org-latex-listings 'minted)
   #+END_SRC

   Because [[https://code.google.com/p/minted/][Minted]] uses [[http://pygments.org][Pygments]] (an external process), we must add the
   =-shell-escape= option to the =org-latex-pdf-process= commands. The
   =tex-compile-commands= variable controls the default compile command for
   Tex- and LaTeX-mode, we can add the flag with a rather dirty statement
   (if anyone finds a nicer way to do this, please let me know).

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'tex-mode
     '(setcar (cdr (cddaar tex-compile-commands)) " -shell-escape "))
   #+END_SRC

   When exporting from Org to LaTeX, use ~latexmk~ for compilation.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'ox-latex
     '(setq org-latex-pdf-process
            '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")))
   #+END_SRC

   For my thesis, I need to use our university's LaTeX class, this snippet
   makes that class available.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load "ox-latex"
     '(progn
        (add-to-list 'org-latex-classes
                     '("ifimaster"
                       "\\documentclass{ifimaster}
   [DEFAULT-PACKAGES]
   [PACKAGES]
   [EXTRA]
   \\usepackage{babel,csquotes,ifimasterforside,url,varioref}"
                      ("\\chapter{%s}" . "\\chapter*{%s}")
                      ("\\section{%s}" . "\\section*{%s}")
                      ("\\subsection{%s}" . "\\subsection*{%s}")
                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
        (add-to-list 'org-latex-classes
                     '("easychair" "\\documentclass{easychair}"
                      ("\\section{%s}" . "\\section*{%s}")
                      ("\\subsection{%s}" . "\\subsection*{%s}")
                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
       (custom-set-variables '(org-export-allow-bind-keywords t))))
   #+END_SRC

** Markdown

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC

   I sometimes use a specialized markdown format, where inline math-blocks
   can be achieved by surrounding a LaTeX formula with =$math$= and
   =$/math$=. Writing these out became tedious, so I wrote a small function.

   #+BEGIN_SRC emacs-lisp
   (defun insert-markdown-inline-math-block ()
     "Inserts an empty math-block if no region is active, otherwise wrap a
   math-block around the region."
     (interactive)
     (let* ((beg (region-beginning))
            (end (region-end))
            (body (if (region-active-p) (buffer-substring beg end) "")))
       (when (region-active-p)
         (delete-region beg end))
       (insert (concat "$math$ " body " $/math$"))
       (search-backward " $/math$")))
   #+END_SRC

   Most of my writing in this markup is in English, so the dictionary is
   set accordingly. The markup is also sensitive to line breaks, so
   =auto-fill-mode= is disabled. Of course we want to bind our lovely
   function to a key!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'markdown-mode-hook
             (lambda ()
               (auto-fill-mode 0)
               (visual-line-mode 1)
               (ispell-change-dictionary "american")
               (local-set-key (kbd "C-c b") 'insert-markdown-inline-math-block)) t)
   #+END_SRC
   
** Elixir

#+NAME: elixir-ligatures
#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :ensure t
  :init  
  (add-hook 'elixir-mode-hook
            (lambda ()
              (push '(">=" . ?\u2265) prettify-symbols-alist)
              (push '("<=" . ?\u2264) prettify-symbols-alist)
              (push '("!=" . ?\u2260) prettify-symbols-alist)
              (push '("==" . ?\u2A75) prettify-symbols-alist)
              (push '("=~" . ?\u2245) prettify-symbols-alist)
              (push '("<-" . ?\u2190) prettify-symbols-alist)
              (push '("->" . ?\u2192) prettify-symbols-alist)
              (push '("<-" . ?\u2190) prettify-symbols-alist)
              (push '("|>" . ?\u25B7) prettify-symbols-alist))))
#+END_SRC

** LSP

   eglot LSP configuration

   #+BEGIN_SRC emacs-lisp
   (require 'eglot)

   ;; elixir-mode LSP
   
   ;; This is optional. It automatically runs `M-x eglot` for you whenever you are in `elixir-mode`:
   (add-hook 'elixir-mode-hook 'eglot-ensure)

   ;; Be sure to edit the path appropriately; use the `.bat` script instead for Windows:
   (add-to-list 'eglot-server-programs '(elixir-mode "~/Downloads/elixir-ls/language_server.sh"))
   #+END_SRC
   
** YASnippet

The configuration below does the following:

It calls yas-minor-mode when =prog-mode-hook= is called.
The yasnippet package gets loaded/required automatically when yas-minor-mode is
called. So if you do not open a buffer with a prog-mode derived major mode, 
then yas-minor-mode is not called, and so yasnippet is not loaded at all.
Once yasnippet is loaded, yas-reload-all is called.

   #+BEGIN_SRC emacs-lisp
   (use-package yasnippet
     :commands (yas-minor-mode) ; autoload `yasnippet' when `yas-minor-mode' is called
                                ; using any means: via a hook or by user
                                ; Feel free to add more commands to this
                                ; list to suit your needs.
     :init ; stuff to do before requiring the package
     (progn
       (add-hook 'prog-mode-hook #'yas-minor-mode))
     :config ; stuff to do after requiring the package
     (progn
       (yas-reload-all)))
   #+END_SRC

** Javascript

#+NAME: Javascript major mode
   #+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
   #+END_SRC

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
    "A keymap for custom bindings.")
  #+END_SRC

** Bindings for built-ins

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "M-p")         'prettify-symbols-mode)
  (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
  (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
  (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
  (define-key custom-bindings-map (kbd "M-]")         'other-frame)
  (define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
  (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
  (define-key custom-bindings-map (kbd "C-c c")       'org-capture)
  ;(define-key custom-bindings-map (kbd "C-c b")       'org-switchb)
  ;(define-key custom-bindings-map (kbd "C-c a")       'org-agenda)
  ;(define-key custom-bindings-map (kbd "C-c l")       'org-store-link)
  (define-key custom-bindings-map (kbd "C-x p")       'projectile-dired)
  (define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
  (define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
  (define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
  (define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
  (define-key custom-bindings-map (kbd "C-c t")
    (lambda () (interactive) (org-agenda nil "n")))
  #+END_SRC

** Bindings for functions defined [[sec:defuns][above]].

  #+BEGIN_SRC emacs-lisp
  (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
  (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
  (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
  (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
  (define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
  (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
  (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
  (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
  (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
  (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
  (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
  (define-key custom-bindings-map (kbd "M-§")     'toggle-shell)
  (define-key custom-bindings-map (kbd "C-x sb") 'org-insert-source-block)
  (dolist (n (number-sequence 1 9))
    (global-set-key (kbd (concat "M-" (int-to-string n)))
                    (lambda () (interactive) (switch-shell n))))
  (define-key custom-bindings-map (kbd "C-c C-q")
    '(lambda ()
       (interactive)
       (focus-mode 1)
       (focus-read-only-mode 1)))
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
  #+END_SRC

  Lastly we need to activate the map by creating and activating the
  =minor-mode=.

  #+BEGIN_SRC emacs-lisp
  (define-minor-mode custom-bindings-mode
    "A mode that activates custom-bindings."
    t nil custom-bindings-map)
  #+END_SRC
